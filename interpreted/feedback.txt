c: @insyri
1. the issue with fractions in computers is the representation and additional computations needed to represent it. a fraction is essentially a representation of a division between two values capable of representing itself as either a terminating or a non-terminating decimals. as binary cannot itself represent itself as a function (in the sense that it can be explicitly defined in a specific range but not in an infinite sense), this would require more steps of computation to resolve an operation. and even thereafter, this could be another limitation of programmers using the language because they might want to define a specific range to optimize the speed of output, example being a programmer may not want to calculate the quotient all the way to 1000 but to 100. i may be interpreting this the wrong way but for the most part this adds more abstraction that would be irregular with programmers that are familiar with the next programming language.
2. in a similar but opposite direction of #1, the use of epsilon as an operator (?) is another abstraction that would limit the programmer to how accurate, or the size of the epsilon. I'm not sure how you would use this though so I may be seeing this the wrong way. Also, when I read `pi ≈ 3.14` or  `3.14 ≈ 22/7` I see this as a statement.
3. with the use of epsilon, I'm being constantly reminded that the asymptotically equal to symbol `≃ U+2243` and congruency symbol `≅ U+2245`. not sure if this is a complaint or not but it feels incomplete with the fact that other operators can be replaced with their symbol equivalents, e.g.: `≥`.
4. usage of special characters like `≥`, `≠`,  and `≈` which are non-standard on an american keyboard (uk keyboards have the logical negation symbol `¬ U+00AC` or possibly the full width version `￢ U+FFE2` idk which) are tedious to type out and see no real benefit in this usage. saving a character in the file only to spend 3 seconds to hold alt and type the alt code.
5. missing modulo operator?
6. cant comment on restrictions, how would you use them? I feel like these would be used as a pre-condition statement.
7. hmsm is a dynamic memory size; if you could represent 12s you must also be able to represent 100000000000000000000s.
8. `x ^ y` is found in other languages to be `logical or` instead of exponentiation, consider `x ** y` for exponentiation.
9. i love the minimalism, i think this would be a really nice language for a python-like use case since it looks like it focuses on mathematical operations for minimal syntax and along with other abstractions to represent mathematical abstracts and notations.
10. seems to be two ways to define a function: `fn name() {}` and `let name() = body`, maybe set on one or define differences useful enough to use one over another for certain cases.

probably too critical of a review given that the syntax was only given, i apologize, i got carried away trying to procrastinate. but in seriousness, other than the specifics making me hesitant, i like this idea a lot and i would be interested how you would tackle such an project.